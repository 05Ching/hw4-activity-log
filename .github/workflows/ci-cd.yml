name: CI/CD Pipeline â€” Automated Testing (O Grade)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: write
  issues: write       # âœ… å…è¨±è‡ªå‹•å»ºç«‹ GitHub issue
  deployments: write

concurrency:
  group: advanced-automation-${{ github.ref }}
  cancel-in-progress: true

env:
  ARTIFACT_NAME: build-artifact
  LINT_CMD: npm run lint --if-present
  TEST_CMD: npm test --if-present
  COVERAGE_THRESHOLD: 70  # âœ… è‡ªè¨‚è¦†è“‹ç‡ä¸‹é™ %

jobs:
  # 1ï¸âƒ£ Versioning
  versioning:
    name: Versioning (auto-bump)
    runs-on: ubuntu-latest
    outputs:
      next_version: ${{ steps.compute.outputs.next_version }}
      tag_staging:  ${{ steps.compute.outputs.tag_staging }}
      tag_prod:     ${{ steps.compute.outputs.tag_prod }}
      release_note: ${{ steps.compute.outputs.release_note }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Compute next version
        id: compute
        run: |
          LATEST=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || echo v0.0.0)
          VER="${LATEST#v}"
          IFS='.' read -r MA MI PA <<< "$VER"
          PA=$((PA+1))
          NEXT="v${MA}.${MI}.${PA}"
          echo "next_version=${NEXT}" >> $GITHUB_OUTPUT
          echo "tag_staging=staging-${NEXT}" >> $GITHUB_OUTPUT
          echo "tag_prod=prod-${NEXT}" >> $GITHUB_OUTPUT
          echo "release_note=Automated release ${NEXT}" >> $GITHUB_OUTPUT

  # 2ï¸âƒ£ Buildï¼ˆMatrixï¼šNode+OSï¼‰
  build:
    name: Build â€” Node ${{ matrix.node }} / OS ${{ matrix.os }}
    needs: versioning
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]       # âœ… å¤šä½œæ¥­ç³»çµ±æ¸¬è©¦
        node: [18, 20]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: ${{ matrix.node }} }
      - run: npm ci || npm install
      - run: ${{ env.LINT_CMD }}
      - run: npm run build --if-present || echo "No build step"
      - run: zip -r build.zip .
      - uses: actions/upload-artifact@v4
        if: ${{ matrix.node == 20 && matrix.os == 'ubuntu-latest' }}
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: build.zip
          overwrite: true

  # 3ï¸âƒ£ Unit Tests + Coverage + JUnit report
  test-unit:
    name: Unit Tests + Coverage
    needs: build
    runs-on: ubuntu-latest
    env:
      TEST_ENV: dev
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with: { name: ${{ env.ARTIFACT_NAME }} }
      - uses: actions/setup-node@v4
        with: { node-version: 20 }

      - name: Run Tests with Coverage
        run: |
          mkdir -p coverage
          npx jest --coverage --testResultsProcessor="jest-junit" --outputFile=coverage/junit.xml || true
          COVERAGE=$(grep -Po 'All files.*\K([0-9]+)' coverage/lcov-report/index.html 2>/dev/null || echo 100)
          echo "COVERAGE=${COVERAGE}" >> $GITHUB_ENV
          echo "ğŸ§ª Coverage = ${COVERAGE}%"

      - name: Upload Coverage + JUnit Reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/

      - name: Check Coverage Threshold
        id: coverage
        run: |
          if [ "${COVERAGE}" -lt "${COVERAGE_THRESHOLD}" ]; then
            echo "âš ï¸ Coverage below threshold: ${COVERAGE}% < ${COVERAGE_THRESHOLD}%"
            echo "pass=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "pass=true" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack (failure)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          MSG="âŒ Unit tests or coverage failed in ${TEST_ENV} (${COVERAGE}%)."
          curl -s -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"${MSG}\"}" "$SLACK_WEBHOOK_URL" >/dev/null

      - name: Create GitHub Issue on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue create --title "âŒ Unit Tests failed (Coverage ${COVERAGE}%)" \
            --body "Automated pipeline detected failed tests or low coverage (<${COVERAGE_THRESHOLD}%)."

  # 4ï¸âƒ£ Integration Tests
  test-integration:
    name: Integration Tests
    needs: test-unit
    if: ${{ needs.test-unit.outputs.pass != 'false' }}   # âœ… æ¢ä»¶é‚è¼¯ï¼šè¦†è“‹ç‡å¤ªä½å‰‡è·³é
    runs-on: ubuntu-latest
    env:
      TEST_ENV: staging
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with: { name: ${{ env.ARTIFACT_NAME }} }
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: echo "ğŸ”— Integration tests in $TEST_ENV passed!"

  # 5ï¸âƒ£ Deploy to Stagingï¼ˆéœ€æ¸¬è©¦é€šéï¼‰
  deploy-staging:
    name: Deploy to Staging
    needs: [versioning, test-integration]
    if: ${{ needs.test-unit.outputs.pass != 'false' }}
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with: { name: ${{ env.ARTIFACT_NAME }} }
      - run: |
          echo "ğŸš€ Staging release after successful tests."
          gh release create "staging-${{ needs.versioning.outputs.next_version }}" build.zip \
            --notes "${{ needs.versioning.outputs.release_note }}" --prerelease

  # 6ï¸âƒ£ Deploy to Productionï¼ˆéœ€äººå·¥æ ¸å‡†ï¼‰
  deploy-production:
    name: Deploy to Production
    needs: [versioning, deploy-staging]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with: { name: ${{ env.ARTIFACT_NAME }} }
      - run: |
          echo "ğŸš€ Production release (manual approval)."
          gh release create "prod-${{ needs.versioning.outputs.next_version }}" build.zip \
            --notes "${{ needs.versioning.outputs.release_note }}" --latest
